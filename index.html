<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Musical Scale Explorer</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Music&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/styles.css">
    
    <!-- Load data constants first -->
    <script src="js/data/constants.js"></script>
    <script src="js/data/staff-positions.js"></script>
    
    <!-- Load core musical logic -->
    <script src="js/core/music-theory.js"></script>
    <script src="js/core/scales.js"></script>
    <script src="js/core/triads.js"></script>
    
    <!-- Load display modules -->
    <script src="js/display/key-signatures.js"></script>
    <script src="js/display/staff-notation.js"></script>
    <script src="js/display/keyboard.js"></script>
    
    <!-- Load UI modules -->
    <script src="js/ui/tables.js"></script>
    <script src="js/ui/controls.js"></script>
    <script src="js/ui/app.js"></script>
    
    <!-- Load audio engine -->
    <script src="js/audio/audio-engine.js"></script>
    <script src="js/audio/playback.js"></script>
</head>
<body>
    <div class="container">
        <h1>Musical Scale Explorer</h1>
        
        <div class="controls">
            <div class="key-signature-section">
                <button class="nav-arrow" id="prevScale">â€¹</button>
                
                <div class="key-signatures">
                    <div class="key-signature">
                        <h4>Bass Clef</h4>
                        <svg id="bassKeySignature" width="200" height="100"></svg>
                    </div>
                    
                    <div style="text-align: center;">
                        <div style="margin-bottom: 10px;">
                            <label for="rootNoteSelect" style="font-size: 16px; font-weight: bold;">Root Note:</label><br>
                            <select id="rootNoteSelect" style="font-size: 16px; padding: 8px;">
                                <option value="C">C</option>
                                <option value="Db">Db</option>
                                <option value="D" selected>D</option>
                                <option value="Eb">Eb</option>
                                <option value="E">E</option>
                                <option value="F">F</option>
                                <option value="F#">F#</option>
                                <option value="Gb">Gb</option>
                                <option value="G">G</option>
                                <option value="Ab">Ab</option>
                                <option value="A">A</option>
                                <option value="Bb">Bb</option>
                                <option value="B">B</option>
                            </select>
                        </div>
                        
                        <div>
                            <label style="font-size: 16px; font-weight: bold;">Scale Type:</label><br>
                            <div id="scaleTypeRadios" class="scale-type-selector" style="margin-top: 8px;">
                                <!-- Radio buttons will be generated here -->
                            </div>
                        </div>
                    </div>
                    
                    <div class="key-signature">
                        <h4>Treble Clef</h4>
                        <svg id="trebleKeySignature" width="200" height="100"></svg>
                    </div>
                </div>
                
                <button class="nav-arrow" id="nextScale">â€º</button>
            </div>
            
            <div id="triadControls" style="display: none; margin-top: 10px;">
                <label for="triadSelect">Triad:</label>
                <select id="triadSelect">
                    <option value="0">I (Tonic)</option>
                    <option value="1">ii (Supertonic)</option>
                    <option value="2">iii (Mediant)</option>
                    <option value="3">IV (Subdominant)</option>
                    <option value="4">V (Dominant)</option>
                    <option value="5">vi (Submediant)</option>
                    <option value="6">viiÂ° (Leading tone)</option>
                </select>
            </div>
        </div>
        
        <div class="scale-info">
            <div>
                <h3>Scale Notes 
                    <button onclick="playCurrentScale()" class="play-btn" title="Play scale">â™«</button>
                    <button onclick="playCurrentScaleUpDown()" class="play-btn" title="Play scale up & down">â™ªâ™«â™ª</button>
                </h3>
                <table id="scaleTable">
                    <thead>
                        <tr>
                            <th>Degree</th>
                            <th>Note</th>
                            <th>Name</th>
                            <th>Play</th>
                        </tr>
                    </thead>
                    <tbody id="scaleTableBody">
                    </tbody>
                </table>
            </div>
            
            <div>
                <h3>Triads</h3>
                <table id="triadTable">
                    <thead>
                        <tr>
                            <th>Degree</th>
                            <th>Triad</th>
                            <th>Notes</th>
                            <th>Quality</th>
                            <th>Play</th>
                        </tr>
                    </thead>
                    <tbody id="triadTableBody">
                    </tbody>
                </table>
            </div>
        </div>
        
        <div class="staff">
            <h3>Staff Notation</h3>
            <div>
                <svg id="trebleStaff" width="600" height="150"></svg>
            </div>
            <div>
                <svg id="bassStaff" width="600" height="150"></svg>
            </div>
        </div>
        
        <div class="keyboard">
            <h3>Piano Keyboard</h3>
            <div id="pianoKeyboard"></div>
        </div>
    </div>

    <script>
        // TESTING - Test the new selector system
        function testScaleSelector() {
            console.log('ðŸŽ›ï¸ Testing Scale Selector System');
            console.log('================================');
            
            const options = getScaleTypeOptions();
            console.log('Available scale types:');
            options.forEach(option => {
                console.log(`  ${option.value} â†’ "${option.label}"`);
            });
            
            console.log('\nTesting scale generation:');
            console.log(`Current: ${currentRoot} ${formatScaleTypeName(currentScaleType)}`);
            
            const scale = generateScale(currentRoot, currentScaleType);
            console.log(`Generated scale: [${scale.join(', ')}]`);
            
            console.log('\nâœ… Scale selector system ready!');
        }
        
        // TESTING - Verify key signatures for different scale types
        function testKeySignatures() {
            console.log('ðŸŽ¼ Testing Key Signatures ðŸŽ¼');
            console.log('============================');
            
            const testCases = [
                { root: 'C', scaleType: 'major', expected: '0 accidentals' },
                { root: 'C', scaleType: 'naturalMinor', expected: '3 flats (Bb, Eb, Ab)' },
                { root: 'F', scaleType: 'major', expected: '1 flat (Bb)' },
                { root: 'F', scaleType: 'naturalMinor', expected: '4 flats (Bb, Eb, Ab, Db)' },
                { root: 'G', scaleType: 'major', expected: '1 sharp (F#)' },
                { root: 'E', scaleType: 'naturalMinor', expected: '1 sharp (F#)' },
                { root: 'A', scaleType: 'naturalMinor', expected: '0 accidentals' }
            ];
            
            testCases.forEach(testCase => {
                const keyData = keySignatures[testCase.scaleType][testCase.root];
                const sharps = keyData.sharps.length;
                const flats = keyData.flats.length;
                
                let actual = '';
                if (sharps > 0) {
                    actual = `${sharps} sharp${sharps > 1 ? 's' : ''} (${keyData.sharps.join(', ')})`;
                } else if (flats > 0) {
                    actual = `${flats} flat${flats > 1 ? 's' : ''} (${keyData.flats.join(', ')})`;
                } else {
                    actual = '0 accidentals';
                }
                
                console.log(`${testCase.root} ${testCase.scaleType}:`);
                console.log(`  Expected: ${testCase.expected}`);
                console.log(`  Actual:   ${actual}`);
                console.log(`  Match: ${actual === testCase.expected ? 'âœ…' : 'âŒ'}`);
                console.log('');
            });
        }
        
        // ACCIDENTAL DETECTION - Phase 1: Logic only, no visual changes
        
        // Determine what note the key signature implies for a given note
        function getImpliedNote(note, keySignature) {
            const baseLetter = note.charAt(0); // C, D, E, F, G, A, B
            
            // Check if this letter is affected by key signature
            const isSharpKey = keySignature.sharps.length > 0;
            const isFlatKey = keySignature.flats.length > 0;
            
            if (isSharpKey) {
                // If the base letter is in the sharps list, it should be sharp
                const sharpLetters = keySignature.sharps.map(s => s.charAt(0));
                if (sharpLetters.includes(baseLetter)) {
                    return baseLetter + '#';
                }
            }
            
            if (isFlatKey) {
                // If the base letter is in the flats list, it should be flat
                const flatLetters = keySignature.flats.map(f => f.charAt(0));
                if (flatLetters.includes(baseLetter)) {
                    return baseLetter + 'b';
                }
            }
            
            // No accidental implied by key signature
            return baseLetter;
        }
        
        // Determine what accidental is needed for a note given the key signature
        function determineAccidental(actualNote, keySignature) {
            const impliedNote = getImpliedNote(actualNote, keySignature);
            
            // If actual note matches what key signature implies, no accidental needed
            if (actualNote === impliedNote) {
                return null;
            }
            
            const baseLetter = actualNote.charAt(0);
            const actualAccidental = actualNote.slice(1); // '', '#', 'b'
            const impliedAccidental = impliedNote.slice(1); // '', '#', 'b'
            
            // Determine what accidental symbol is needed
            if (impliedAccidental === '' && actualAccidental === '#') {
                return 'sharp';
            } else if (impliedAccidental === '' && actualAccidental === 'b') {
                return 'flat';
            } else if (impliedAccidental === '#' && actualAccidental === '') {
                return 'natural';
            } else if (impliedAccidental === 'b' && actualAccidental === '') {
                return 'natural';
            } else if (impliedAccidental === '#' && actualAccidental === 'b') {
                return 'flat';
            } else if (impliedAccidental === 'b' && actualAccidental === '#') {
                return 'sharp';
            }
            
            return null; // No accidental needed
        }
        
        // Get all required accidentals for a scale
        function getRequiredAccidentals(scale, keySignature) {
            const accidentals = [];
            
            scale.forEach((note, index) => {
                const accidental = determineAccidental(note, keySignature);
                if (accidental) {
                    accidentals.push({
                        noteIndex: index,
                        note: note,
                        accidental: accidental, // 'sharp', 'flat', 'natural'
                        implied: getImpliedNote(note, keySignature),
                        reason: `Key signature implies ${getImpliedNote(note, keySignature)}, scale has ${note}`
                    });
                }
            });
            
            return accidentals;
        }
        
        // ACCIDENTAL VISUAL RENDERING - Phase 2: Safe visual addition
        
        // Feature flag for easy disable/enable
        const SHOW_ACCIDENTALS = true;
        
        // Draw an accidental symbol next to a note
        function drawAccidental(svg, accidental, noteX, noteY) {
            if (!SHOW_ACCIDENTALS) return;
            
            // Position accidental 15px to the left of the note (safe distance)
            const accidentalX = noteX - 15;
            const accidentalY = noteY;
            
            // Professional musical symbols using Unicode + musical font
            const symbols = { 
                'sharp': 'â™¯',    // U+266F
                'flat': 'â™­',     // U+266D  
                'natural': 'â™®'   // U+266E
            };
            
            const accidentalElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            accidentalElement.setAttribute('x', accidentalX);
            accidentalElement.setAttribute('y', accidentalY + 6); // Adjusted for better alignment with musical font
            accidentalElement.setAttribute('font-size', '28'); // Much larger to match staff proportions
            accidentalElement.setAttribute('font-family', 'Noto Music, Bravura, serif'); // Musical font with fallbacks
            accidentalElement.setAttribute('fill', '#333'); // Darker for better contrast
            accidentalElement.setAttribute('text-anchor', 'middle'); // Center the symbol
            accidentalElement.setAttribute('font-weight', 'normal'); // Musical fonts work best at normal weight
            accidentalElement.textContent = symbols[accidental];
            
            // Add data attribute for debugging/testing
            accidentalElement.setAttribute('data-accidental', accidental);
            accidentalElement.setAttribute('class', 'musical-accidental');
            
            svg.appendChild(accidentalElement);
        }
        
        // Add accidentals to already-positioned notes (safe approach)
        function addAccidentalsToStaff(svg, clef) {
            if (!SHOW_ACCIDENTALS || currentScaleType === 'major') return;
            
            try {
                // Generate current scale and get required accidentals
                const scale = generateScale(currentRoot, currentScaleType);
                const keyData = keySignatures[currentScaleType][currentRoot];
                const requiredAccidentals = getRequiredAccidentals(scale, keyData);
                
                if (requiredAccidentals.length === 0) return;
                
                // Find all note circles in the SVG (they have 'cx' and 'cy' attributes)
                const noteElements = svg.querySelectorAll('circle[cx][cy]');
                
                requiredAccidentals.forEach(acc => {
                    // Find the note element for this scale degree
                    if (acc.noteIndex < noteElements.length) {
                        const noteElement = noteElements[acc.noteIndex];
                        const noteX = parseFloat(noteElement.getAttribute('cx'));
                        const noteY = parseFloat(noteElement.getAttribute('cy'));
                        
                        drawAccidental(svg, acc.accidental, noteX, noteY);
                    }
                });
                
            } catch (error) {
                console.warn('Error adding accidentals to staff:', error);
                // Fail gracefully - notes still display correctly
            }
        }
        
        // TESTING - Test musical font rendering
        function testMusicalFont() {
            console.log('ðŸŽ¼ Testing Musical Font Rendering ðŸŽ¼');
            console.log('====================================');
            
            // Test if musical font is loaded
            const testElement = document.createElement('span');
            testElement.style.fontFamily = 'Noto Music, Bravura, serif';
            testElement.style.fontSize = '18px';
            testElement.textContent = 'â™¯â™­â™®';
            document.body.appendChild(testElement);
            
            // Check computed font
            const computedStyle = window.getComputedStyle(testElement);
            console.log('Font family in use:', computedStyle.fontFamily);
            
            // Clean up
            document.body.removeChild(testElement);
            
            console.log('Musical symbols test:');
            console.log('  Sharp: â™¯ (U+266F)');
            console.log('  Flat: â™­ (U+266D)');
            console.log('  Natural: â™® (U+266E)');
            
            console.log('\nðŸ’¡ Switch to C Harmonic Minor to see improved â™® symbol');
            console.log('ðŸ’¡ The accidentals should now use professional musical font rendering');
        }
        
        // TESTING - Test visual accidentals on staff
        function testVisualAccidentals() {
            console.log('ðŸŽ¼ Testing Visual Accidentals ðŸŽ¼');
            console.log('================================');
            
            console.log('Current settings:');
            console.log(`  Root: ${currentRoot}`);
            console.log(`  Scale Type: ${currentScaleType}`);
            console.log(`  Show Accidentals: ${SHOW_ACCIDENTALS}`);
            
            if (currentScaleType === 'major') {
                console.log('  â„¹ï¸  Major scales should show no accidentals');
                return;
            }
            
            const scale = generateScale(currentRoot, currentScaleType);
            const keyData = keySignatures[currentScaleType][currentRoot];
            const accidentals = getRequiredAccidentals(scale, keyData);
            
            console.log(`\nScale analysis:`);
            console.log(`  Scale: [${scale.join(', ')}]`);
            console.log(`  Key signature: ${keyData.sharps.length} sharps, ${keyData.flats.length} flats`);
            console.log(`  Required accidentals: ${accidentals.length}`);
            
            if (accidentals.length > 0) {
                console.log(`  Expected to see on staff:`);
                accidentals.forEach(acc => {
                    const symbol = { 'sharp': 'â™¯', 'flat': 'â™­', 'natural': 'â™®' }[acc.accidental];
                    console.log(`    ${symbol} before ${acc.note} (degree ${acc.noteIndex + 1})`);
                });
            }
            
            // Check if accidentals are actually rendered
            const trebleStaff = document.getElementById('trebleStaff');
            const bassStaff = document.getElementById('bassStaff');
            
            if (trebleStaff) {
                const trebleAccidentals = trebleStaff.querySelectorAll('[data-accidental]');
                console.log(`\nTreble staff: ${trebleAccidentals.length} accidental symbols found`);
            }
            
            if (bassStaff) {
                const bassAccidentals = bassStaff.querySelectorAll('[data-accidental]');
                console.log(`Bass staff: ${bassAccidentals.length} accidental symbols found`);
            }
            
            console.log('\nðŸ’¡ Try switching to C Harmonic Minor to see â™® before B');
            console.log('ðŸ’¡ Try switching to C Melodic Minor to see â™® before A and B');
        }
        
        // TESTING - Test accidental detection logic
        function testAccidentalDetection() {
            console.log('ðŸŽµ Testing Accidental Detection Logic ðŸŽµ');
            console.log('=========================================');
            
            const testCases = [
                { root: 'C', scaleType: 'major', expectedAccidentals: 0 },
                { root: 'C', scaleType: 'naturalMinor', expectedAccidentals: 0 },
                { root: 'C', scaleType: 'harmonicMinor', expectedAccidentals: 1, expectedNote: 'B' },
                { root: 'C', scaleType: 'melodicMinor', expectedAccidentals: 2, expectedNotes: ['A', 'B'] },
                { root: 'F', scaleType: 'harmonicMinor', expectedAccidentals: 1, expectedNote: 'E' },
                { root: 'A', scaleType: 'harmonicMinor', expectedAccidentals: 1, expectedNote: 'G#' }
            ];
            
            testCases.forEach(testCase => {
                const scale = generateScale(testCase.root, testCase.scaleType);
                const keyData = keySignatures[testCase.scaleType][testCase.root];
                const accidentals = getRequiredAccidentals(scale, keyData);
                
                console.log(`\n${testCase.root} ${testCase.scaleType}:`);
                console.log(`  Scale: [${scale.join(', ')}]`);
                console.log(`  Key signature: ${keyData.sharps.length} sharps, ${keyData.flats.length} flats`);
                console.log(`  Expected accidentals: ${testCase.expectedAccidentals}`);
                console.log(`  Found accidentals: ${accidentals.length}`);
                
                if (accidentals.length > 0) {
                    accidentals.forEach(acc => {
                        console.log(`    ${acc.note} needs ${acc.accidental} (${acc.reason})`);
                    });
                }
                
                const match = accidentals.length === testCase.expectedAccidentals;
                console.log(`  Match: ${match ? 'âœ…' : 'âŒ'}`);
            });
            
            console.log('\nâœ… Accidental detection testing complete!');
        }
        
        // TESTING - Validate minor scale patterns with proper enharmonic spelling
        function validateMinorScales() {
            console.log('ðŸŽµ Testing Minor Scale Patterns with Enharmonic Spelling ðŸŽµ');
            console.log('==========================================================');
            
            // Expected results for validation
            const expectedMinorScales = {
                // Flat minor keys (use flats)
                'C': {
                    naturalMinor: ['C', 'D', 'Eb', 'F', 'G', 'Ab', 'Bb'],
                    harmonicMinor: ['C', 'D', 'Eb', 'F', 'G', 'Ab', 'B'],
                    melodicMinor: ['C', 'D', 'Eb', 'F', 'G', 'A', 'B']
                },
                'F': {
                    naturalMinor: ['F', 'G', 'Ab', 'Bb', 'C', 'Db', 'Eb'],
                    harmonicMinor: ['F', 'G', 'Ab', 'Bb', 'C', 'Db', 'E'],
                    melodicMinor: ['F', 'G', 'Ab', 'Bb', 'C', 'D', 'E']
                },
                // Sharp minor keys (keep sharps)
                'E': {
                    naturalMinor: ['E', 'F#', 'G', 'A', 'B', 'C', 'D'],
                    harmonicMinor: ['E', 'F#', 'G', 'A', 'B', 'C', 'D#'],
                    melodicMinor: ['E', 'F#', 'G', 'A', 'B', 'C#', 'D#']
                },
                'B': {
                    naturalMinor: ['B', 'C#', 'D', 'E', 'F#', 'G', 'A'],
                    harmonicMinor: ['B', 'C#', 'D', 'E', 'F#', 'G', 'A#'],
                    melodicMinor: ['B', 'C#', 'D', 'E', 'F#', 'G#', 'A#']
                }
            };
            
            const scaleTypes = ['naturalMinor', 'harmonicMinor', 'melodicMinor'];
            
            Object.keys(expectedMinorScales).forEach(key => {
                console.log(`\nðŸ” ${key} Minor Scales:`);
                scaleTypes.forEach(scaleType => {
                    const generated = generateScale(key, scaleType);
                    const expected = expectedMinorScales[key][scaleType];
                    const match = JSON.stringify(generated) === JSON.stringify(expected);
                    
                    console.log(`  ${scaleType}:`);
                    console.log(`    Generated: [${generated.join(', ')}]`);
                    console.log(`    Expected:  [${expected.join(', ')}]`);
                    console.log(`    Match: ${match ? 'âœ…' : 'âŒ'}`);
                });
            });
            
            console.log('\nâœ… Minor scale enharmonic spelling validation complete!');
        }
        
        // Generate all major scales using the new system
        function generateAllMajorScales() {
            const rootNotes = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'F#', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
            const generatedScales = {};
            
            rootNotes.forEach(root => {
                generatedScales[root] = generateScale(root, 'major');
            });
            
            return generatedScales;
        }
        
        function updateDisplay() {
            updateScaleTable();
            updateTriadTable();
            updateKeySignatures();
            updateStaff();
            updateKeyboard();
        }
        
        function updateKeySignatures() {
            drawKeySignature('trebleKeySignature', 'treble');
            drawKeySignature('bassKeySignature', 'bass');
        }
        
        function drawKeySignature(svgId, clef) {
            const svg = document.getElementById(svgId);
            svg.innerHTML = '';
            
            // Define positioning for small key signature display
            const staffTop = 20;
            const staffSpacing = 12;
            
            // Draw staff lines
            for (let i = 0; i < 5; i++) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', 10);
                line.setAttribute('y1', staffTop + i * staffSpacing);
                line.setAttribute('x2', 190);
                line.setAttribute('y2', staffTop + i * staffSpacing);
                line.setAttribute('stroke', '#333');
                line.setAttribute('stroke-width', '1');
                svg.appendChild(line);
            }
            
            // Draw clef symbol (larger to match main staff)
            const clefText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            clefText.setAttribute('x', 5);
            clefText.setAttribute('y', staffTop + (clef === 'treble' ? 35 : 30));
            clefText.setAttribute('font-family', 'serif');
            clefText.setAttribute('font-size', '36');
            clefText.textContent = clef === 'treble' ? 'ð„ž' : 'ð„¢';
            svg.appendChild(clefText);
            
            // Draw sharps or flats using consistent positioning
            drawKeySignatureAccidentals(svg, clef, 35, staffSpacing, staffTop);
        }
        
        function updateStaff() {
            drawStaff('trebleStaff', 'treble');
            drawStaff('bassStaff', 'bass');
        }
        
        function drawStaff(svgId, clef) {
            const svg = document.getElementById(svgId);
            svg.innerHTML = '';
            
            // Adjust SVG width for inversions
            const svgWidth = showMode === 'triad' ? 800 : 600;
            svg.setAttribute('width', svgWidth);
            
            // Define staff positioning - everything else will be relative to this
            const staffTop = 50; // Moved up another 5px (was 55, now 50)
            const staffSpacing = 15;
            
            // Draw staff lines
            for (let i = 0; i < 5; i++) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', 50);
                line.setAttribute('y1', staffTop + i * staffSpacing);
                line.setAttribute('x2', svgWidth - 50);
                line.setAttribute('y2', staffTop + i * staffSpacing);
                line.setAttribute('stroke', '#333');
                line.setAttribute('stroke-width', '1');
                svg.appendChild(line);
            }
            
            // Draw clef symbol (relative to staff)
            const clefText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            clefText.setAttribute('x', 15);
            clefText.setAttribute('y', staffTop + (clef === 'treble' ? 45 : 35));
            clefText.setAttribute('font-family', 'serif');
            clefText.setAttribute('font-size', '48');
            clefText.textContent = clef === 'treble' ? 'ð„ž' : 'ð„¢';
            svg.appendChild(clefText);
            
            // Draw key signature after clef
            drawStaffKeySignature(svg, clef, 70, staffTop, staffSpacing);
            
            if (showMode === 'all') {
                drawScaleNotes(svg, clef, 140, staffTop, staffSpacing);
            } else {
                drawTriadWithInversions(svg, clef, 140, staffTop, staffSpacing);
            }
        }
        
        function drawStaffKeySignature(svg, clef, startX, staffTop, staffSpacing) {
            drawKeySignatureAccidentals(svg, clef, startX, staffSpacing, staffTop);
        }
        
        function drawKeySignatureAccidentals(svg, clef, startX, staffSpacing, staffTop) {
            const keyData = keySignatures[currentScaleType][currentRoot];
            let xPos = startX;
            
            // Calculate staff line and space positions (relative to staffTop)
            const line5 = staffTop; // 5th line (top line visually)
            const space4 = staffTop + staffSpacing * 0.5; // 4th space
            const line4 = staffTop + staffSpacing; // 4th line
            const space3 = staffTop + staffSpacing * 1.5; // 3rd space
            const line3 = staffTop + staffSpacing * 2; // 3rd line (middle)
            const space2 = staffTop + staffSpacing * 2.5; // 2nd space
            const line2 = staffTop + staffSpacing * 3; // 2nd line
            const space1 = staffTop + staffSpacing * 3.5; // 1st space
            const line1 = staffTop + staffSpacing * 4; // 1st line (bottom line visually)
            const space5 = staffTop - staffSpacing * 0.5; // 5th space (above staff)
            
            // Correct sharp positions (standard music notation)
            const sharpPositions = clef === 'treble' ? {
                'F#': line5, 'C#': space3, 'G#': space5, 'D#': line4, 'A#': space2, 'E#': space4, 'B#': line3
            } : {
                'F#': line4, 'C#': space2, 'G#': space4, 'D#': line3, 'A#': space1, 'E#': space3, 'B#': line2
            };
            
            // Correct flat positions (standard music notation)
            const flatPositions = clef === 'treble' ? {
                'Bb': line3, 'Eb': space4, 'Ab': space2, 'Db': line4, 'Gb': line2, 'Cb': space3, 'Fb': space1
            } : {
                'Bb': line2, 'Eb': space3, 'Ab': space1, 'Db': line3, 'Gb': line1, 'Cb': space2, 'Fb': line4
            };
            
            // Draw sharps
            keyData.sharps.forEach((sharp, index) => {
                const sharpSymbol = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                sharpSymbol.setAttribute('x', xPos);
                sharpSymbol.setAttribute('y', sharpPositions[sharp] + staffSpacing * 0.5);
                sharpSymbol.setAttribute('font-family', 'serif');
                sharpSymbol.setAttribute('font-size', staffSpacing * 1.6);
                sharpSymbol.setAttribute('font-weight', 'bold');
                sharpSymbol.textContent = 'â™¯';
                svg.appendChild(sharpSymbol);
                xPos += staffSpacing * 0.7;
            });
            
            // Draw flats
            keyData.flats.forEach((flat, index) => {
                const flatSymbol = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                flatSymbol.setAttribute('x', xPos);
                flatSymbol.setAttribute('y', flatPositions[flat] + staffSpacing * 0.5);
                flatSymbol.setAttribute('font-family', 'serif');
                flatSymbol.setAttribute('font-size', staffSpacing * 1.6);
                flatSymbol.setAttribute('font-weight', 'bold');
                flatSymbol.textContent = 'â™­';
                svg.appendChild(flatSymbol);
                xPos += staffSpacing * 0.7;
            });
        }
        
        function drawScaleNotes(svg, clef, startX = 100, staffTop = 50, staffSpacing = 15) {
            // Generate current scale dynamically
            const scaleNotes = generateScale(currentRoot, currentScaleType);
            
            // Sort notes in ascending pitch order starting from the root
            const noteOrder = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const rootIndex = noteOrder.indexOf(getChromaticEquivalent(currentRoot));
            
            // Create ascending order starting from root with octave adjustments
            const sortedNotes = scaleNotes.map(note => {
                const noteIndex = noteOrder.indexOf(getChromaticEquivalent(note));
                let octaveOffset = 0;
                
                // If note is lower than root note, move it up an octave
                if (noteIndex < rootIndex) {
                    octaveOffset = 1;
                }
                
                return { note: note, octave: octaveOffset };
            });
            
            // For bass clef, use natural octave placement for each key
            if (clef === 'bass') {
                // Natural starting octaves for bass clef - what sounds and reads best
                const bassOctaveAdjustments = {
                    'C': 0,    // C3 to C4 - natural middle range
                    'Db': 0,   // Db3 to C4 - moved up an octave
                    'D': 0,    // D3 to C#4 - natural placement
                    'Eb': -1,  // Eb2 to D3 - flat key, lower is natural
                    'E': 0,    // E3 to D#4 - natural sharp key placement
                    'F': -1,   // F2 to E3 - moved down an octave
                    'F#': 0,   // F#3 to E#4 - sharp key, natural high
                    'Gb': -1,  // Gb2 to F3 - flat key, lower placement
                    'G': -1,   // G2 to F#3 - moved down an octave
                    'Ab': -1,  // Ab2 to G3 - flat key comfort zone
                    'A': -1,   // A2 to G#3 - moved down an octave
                    'Bb': -1,  // Bb2 to A3 - flat key, lower is comfortable
                    'B': -1    // B2 to A#3 - moved down an octave
                };
                
                const adjustment = bassOctaveAdjustments[currentRoot] || 0;
                sortedNotes.forEach(noteObj => {
                    noteObj.octave += adjustment;
                });
            }
            
            // Correct staff positions - relative to staffTop (keeping working system)
            const basePositions = clef === 'treble' ? 
                {'C': staffTop + 75, 'C#': staffTop + 75, 'Db': staffTop + 67.5, 'D': staffTop + 67.5, 'D#': staffTop + 67.5, 'Eb': staffTop + 60, 'E': staffTop + 60, 'E#': staffTop + 60, 'F': staffTop + 52.5, 'F#': staffTop + 52.5, 'Gb': staffTop + 45, 'G': staffTop + 45, 'G#': staffTop + 45, 'Ab': staffTop + 37.5, 'A': staffTop + 37.5, 'A#': staffTop + 37.5, 'Bb': staffTop + 30, 'B': staffTop + 30, 'B#': staffTop + 75, 'Cb': staffTop + 75, 'Fb': staffTop + 52.5} :
                {'C': staffTop + 37.5, 'C#': staffTop + 37.5, 'Db': staffTop + 30, 'D': staffTop + 30, 'D#': staffTop + 30, 'Eb': staffTop + 22.5, 'E': staffTop + 22.5, 'E#': staffTop + 22.5, 'F': staffTop + 15, 'F#': staffTop + 15, 'Gb': staffTop + 7.5, 'G': staffTop + 7.5, 'G#': staffTop + 7.5, 'Ab': staffTop, 'A': staffTop, 'A#': staffTop, 'Bb': staffTop - 7.5, 'B': staffTop - 7.5, 'B#': staffTop + 37.5, 'Cb': staffTop + 37.5, 'Fb': staffTop + 15};
            
            sortedNotes.forEach((noteObj, index) => {
                const x = startX + index * 60;
                const baseY = basePositions[noteObj.note];
                const y = baseY - (noteObj.octave * 52.5); // Apply octave offset like triads
                
                drawNote(svg, x, y, 'note-highlighted');
                drawLedgerLines(svg, x, y, clef, staffTop, staffSpacing);
                
                // Add note label
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x);
                text.setAttribute('y', y + 25);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', '12');
                text.textContent = noteObj.note;
                svg.appendChild(text);
            });
            
            // Phase 2: Add accidentals after all notes are positioned (safe approach)
            addAccidentalsToStaff(svg, clef);
        }
        
        function drawTriadWithInversions(svg, clef, startX = 100, staffTop = 65, staffSpacing = 15) {
            const triadNotes = getTriadNotes(selectedTriad);
            const [root, third, fifth] = triadNotes;
            
            // Calculate proper pitch positions for each inversion
            function getInversionNotes(bassNote, chordTones) {
                const noteOrder = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                const bassIndex = noteOrder.indexOf(getChromaticEquivalent(bassNote));
                
                return chordTones.map(note => {
                    const noteIndex = noteOrder.indexOf(getChromaticEquivalent(note));
                    let octaveOffset = 0;
                    
                    // If note is lower than bass note, move it up an octave
                    if (noteIndex < bassIndex) {
                        octaveOffset = 1;
                    }
                    
                    return { note: note, octave: octaveOffset };
                });
            }
            
            const inversions = [
                { name: 'Root Position', bass: root, notes: getInversionNotes(root, [root, third, fifth]) },
                { name: '1st Inversion', bass: third, notes: getInversionNotes(third, [third, fifth, root]) },
                { name: '2nd Inversion', bass: fifth, notes: getInversionNotes(fifth, [fifth, root, third]) }
            ];
            
            // Base staff positions - relative to staffTop (keeping original working logic)
            const basePositions = clef === 'treble' ? {
                'C': staffTop + 75, 'C#': staffTop + 75, 'Db': staffTop + 67.5, 'D': staffTop + 67.5, 'D#': staffTop + 67.5, 'Eb': staffTop + 60, 
                'E': staffTop + 60, 'E#': staffTop + 60, 'F': staffTop + 52.5, 'F#': staffTop + 52.5, 'Gb': staffTop + 45, 'G': staffTop + 45, 
                'G#': staffTop + 45, 'Ab': staffTop + 37.5, 'A': staffTop + 37.5, 'A#': staffTop + 37.5, 'Bb': staffTop + 30, 'B': staffTop + 30,
                'B#': staffTop + 75, 'Cb': staffTop + 75, 'Fb': staffTop + 52.5
            } : {
                'C': staffTop + 37.5, 'C#': staffTop + 37.5, 'Db': staffTop + 30, 'D': staffTop + 30, 'D#': staffTop + 30, 'Eb': staffTop + 22.5, 
                'E': staffTop + 22.5, 'E#': staffTop + 22.5, 'F': staffTop + 15, 'F#': staffTop + 15, 'Gb': staffTop + 7.5, 'G': staffTop + 7.5, 
                'G#': staffTop + 7.5, 'Ab': staffTop, 'A': staffTop, 'A#': staffTop, 'Bb': staffTop - 7.5, 'B': staffTop - 7.5,
                'B#': staffTop + 37.5, 'Cb': staffTop + 37.5, 'Fb': staffTop + 15
            };
            
            inversions.forEach((inversion, invIndex) => {
                const inversionStartX = startX + invIndex * 200;
                
                // Draw inversion label (positioned relative to staffTop with proper clearance)
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', inversionStartX + 60);
                label.setAttribute('y', staffTop - 30); // 30px above the staff for more clearance
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('font-size', '12');
                label.setAttribute('font-weight', 'bold');
                label.textContent = inversion.name;
                svg.appendChild(label);
                
                // Draw the three notes with proper octave positioning
                inversion.notes.forEach((noteObj, noteIndex) => {
                    const x = inversionStartX + noteIndex * 30;
                    const baseY = basePositions[noteObj.note];
                    // Each octave up moves the note 52.5 pixels higher (7 staff positions * 7.5 pixels)
                    let y = baseY - (noteObj.octave * 52.5);
                    
                    // If the starting note (bass note) is above threshold, move entire triad down an octave
                    if (noteIndex === 0 && y < staffTop + 15) { // Relative threshold: staffTop + 15 (4th line)
                        // Move all notes in this inversion down an octave
                        inversion.notes.forEach(n => n.octave -= 1);
                        y = baseY - (noteObj.octave * 52.5);
                    }
                    
                    drawNote(svg, x, y, 'note-triad');
                    drawLedgerLines(svg, x, y, clef, staffTop, staffSpacing);
                    
                    // Add note label
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', x);
                    text.setAttribute('y', y + 25);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('font-size', '10');
                    text.textContent = noteObj.note;
                    svg.appendChild(text);
                });
            });
        }
        
        function drawNote(svg, x, y, className) {
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', x);
            circle.setAttribute('cy', y);
            circle.setAttribute('r', 6);
            circle.setAttribute('class', className);
            svg.appendChild(circle);
        }
        
        function drawLedgerLines(svg, x, y, clef, staffTop = 35, staffSpacing = 15) {
            // Draw ledger lines for notes outside the staff (relative to staffTop)
            const staffBottom = staffTop + (4 * staffSpacing); // Bottom line of staff
            const needsLedger = (y < staffTop || y >= staffBottom + staffSpacing);
            
            if (needsLedger) {
                if (y >= staffBottom + staffSpacing) {
                    // Below staff - draw ledger lines
                    for (let ly = staffBottom + staffSpacing; ly <= y; ly += staffSpacing * 0.5) {
                        const ledger = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        ledger.setAttribute('x1', x - 10);
                        ledger.setAttribute('y1', ly);
                        ledger.setAttribute('x2', x + 10);
                        ledger.setAttribute('y2', ly);
                        ledger.setAttribute('stroke', '#333');
                        ledger.setAttribute('stroke-width', '1');
                        svg.appendChild(ledger);
                    }
                } else if (y < staffTop) {
                    // Above staff - draw ledger lines
                    for (let ly = staffTop - staffSpacing; ly >= y; ly -= staffSpacing) {
                        const ledger = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        ledger.setAttribute('x1', x - 10);
                        ledger.setAttribute('y1', ly);
                        ledger.setAttribute('x2', x + 10);
                        ledger.setAttribute('y2', ly);
                        ledger.setAttribute('stroke', '#333');
                        ledger.setAttribute('stroke-width', '1');
                        svg.appendChild(ledger);
                    }
                }
            }
        }
        
        function updateKeyboard() {
            const keyboard = document.getElementById('pianoKeyboard');
            keyboard.innerHTML = '';
            
            // Generate current scale dynamically
            const currentScale = generateScale(currentRoot, currentScaleType);
            const notesToHighlight = showMode === 'all' ? currentScale : getTriadNotes(selectedTriad);
            const rootNote = showMode === 'all' ? currentRoot : getTriadNotes(selectedTriad)[0];
            
            // Create four octaves of keys
            for (let octave = 0; octave < 4; octave++) {
                whiteKeys.forEach((key, index) => {
                    const keyDiv = document.createElement('div');
                    keyDiv.className = 'piano-key';
                    
                    const whiteKeyDiv = document.createElement('div');
                    whiteKeyDiv.className = 'white-key';
                    
                    // Apply highlighting
                    const chromaticRoot = getChromaticEquivalent(rootNote);
                    const chromaticNotes = notesToHighlight.map(note => getChromaticEquivalent(note));
                    
                    if (key === chromaticRoot || key === rootNote) {
                        whiteKeyDiv.classList.add('root-highlighted');
                    } else if (chromaticNotes.includes(key) || notesToHighlight.includes(key)) {
                        whiteKeyDiv.classList.add(showMode === 'triad' ? 'triad-highlighted' : 'highlighted');
                    }
                    
                    const label = document.createElement('div');
                    label.className = 'key-label';
                    label.textContent = key;
                    whiteKeyDiv.appendChild(label);
                    
                    keyDiv.appendChild(whiteKeyDiv);
                    
                    // Add black key if it exists
                    if (blackKeys[index]) {
                        const blackKeyDiv = document.createElement('div');
                        blackKeyDiv.className = 'black-key';
                        blackKeyDiv.style.left = '30px';
                        
                        // Apply highlighting to black keys
                        const chromaticRoot = getChromaticEquivalent(rootNote);
                        const chromaticNotes = notesToHighlight.map(note => getChromaticEquivalent(note));
                        
                        if (blackKeys[index] === chromaticRoot) {
                            blackKeyDiv.classList.add('root-highlighted');
                        } else if (chromaticNotes.includes(blackKeys[index])) {
                            blackKeyDiv.classList.add(showMode === 'triad' ? 'triad-highlighted' : 'highlighted');
                        }
                        
                        const blackLabel = document.createElement('div');
                        blackLabel.className = 'key-label';
                        blackLabel.textContent = blackKeys[index];
                        blackKeyDiv.appendChild(blackLabel);
                        
                        keyDiv.appendChild(blackKeyDiv);
                    }
                    
                    keyboard.appendChild(keyDiv);
                });
            }
        }
        
        // Legacy event listeners removed - now handled in initializeApp()
        
        document.getElementById('triadSelect').addEventListener('change', function() {
            selectedTriad = parseInt(this.value);
            updateDisplay();
        });
        
        // Initialize
        updateDisplay();
    </script>
    
    <script>
        // Initialize audio playback
        let scalePlayback = new ScalePlayback();
        let audioInitialized = false;
        
        // Initialize audio on first user interaction
        async function initializeAudio() {
            if (!audioInitialized) {
                try {
                    await scalePlayback.initialize();
                    audioInitialized = true;
                    console.log('Audio initialized');
                } catch (error) {
                    console.error('Failed to initialize audio:', error);
                }
            }
        }
        
        // Audio playback functions
        async function playCurrentScale() {
            await initializeAudio();
            const scale = getCurrentScale();
            if (scale && scale.length > 0) {
                await scalePlayback.playScale(scale);
            }
        }
        
        async function playCurrentScaleUpDown() {
            await initializeAudio();
            const scale = getCurrentScale();
            if (scale && scale.length > 0) {
                await scalePlayback.playScaleAscendingDescending(scale);
            }
        }
        
        async function playTriadChord(triadNotes) {
            await initializeAudio();
            if (triadNotes && triadNotes.length === 3) {
                await scalePlayback.playTriad(triadNotes);
            }
        }
        
        async function playTriadArpeggio(triadNotes) {
            await initializeAudio();
            if (triadNotes && triadNotes.length === 3) {
                await scalePlayback.playTriadArpeggio(triadNotes);
            }
        }
        
        async function playIndividualNote(noteName) {
            await initializeAudio();
            if (noteName) {
                await scalePlayback.playNote(noteName);
            }
        }
        
        // Helper function to get current scale notes
        function getCurrentScale() {
            return generateScale(currentRoot, currentScaleType);
        }
    </script>
</body>
</html>
